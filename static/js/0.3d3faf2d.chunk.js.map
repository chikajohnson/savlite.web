{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","../node_modules/react-hook-form/dist/react-hook-form.es.js"],"names":["_slicedToArray","arr","i","Array","isArray","Symbol","iterator","Object","prototype","toString","call","_arr","_n","_d","_e","undefined","_s","_i","next","done","push","value","length","err","TypeError","VALIDATION_MODE","EVENTS","INPUT_VALIDATION_RULES","attachEventListeners","field","handleChange","isRadioOrCheckbox","ref","addEventListener","isUndefined","val","isNullOrUndefined","isObjectType","isObject","reIsDeepProp","reIsPlainProp","rePropName","reEscapeChar","reIsUint","isIndex","test","set","object","path","index","tempPath","isKey","string","result","replace","match","number","quote","stringToPath","lastIndex","key","newValue","objValue","combineFieldValues","data","entries","reduce","previous","indexOf","assign","removeAllEventListeners","validateWithStateUpdate","removeEventListener","isRadioInput","type","isCheckBoxInput","isDetached","element","HTMLElement","nodeType","Node","DOCUMENT_NODE","parentNode","findRemovedFieldAndRemoveListener","fields","forceDelete","mutationWatcher","name","fieldValue","options","forEach","option","disconnect","splice","defaultReturn","isValid","getRadioValue","checked","isMultipleSelect","isEmptyString","defaultResult","validResult","getCheckboxValue","values","filter","map","attributes","getFieldValue","files","selected","getMultipleSelectValue","getFieldsValues","isEmptyObject","keys","isSameError","error","message","shouldUpdateWithError","errors","validFields","fieldsWithValidation","isFieldValid","isFormValid","currentFieldError","existFieldError","has","isManual","isRegex","RegExp","getValueAndMessage","validationData","isPureObject","isString","displayNativeError","nativeValidation","setCustomValidity","isFunction","isBoolean","getValidateError","nativeError","isStringValue","appendErrors","validateAllFieldCriteria","types","validateField","fieldsRef","a","valueAsNumber","valueAsDate","required","maxLength","minLength","min","max","pattern","validate","current","isRadio","isCheckBox","isEmpty","bind","appendErrorsCurry","maxValue","maxMessage","minValue","minMessage","valueNumber","parseFloat","exceedMax","exceedMin","valueDate","Date","maxLengthValue","maxLengthMessage","minLengthValue","minLengthMessage","inputLength","patternValue","patternMessage","validateRef","validateError","validateFunctions","Promise","resolve","validateResult","validationResult","parseErrorSchema","inner","validateWithSchema","validationSchema","validationSchemaOption","attachNativeValidation","rules","ruleValue","source","get","obj","defaultValue","split","Boolean","getDefaultValue","defaultValues","isPrimitive","getPath$1","parentPath","flatArray","list","b","concat","getPath","item","pathWithIndex","objectValue","pathWithKey","assignWatchFields","fieldValues","fieldName","watchFields","combinedDefaultValues","add","omitValidFields","errorFields","validFieldNames","some","validFieldName","onDomRemove","onDetachCallback","observer","MutationObserver","observe","window","document","childList","subtree","__rest","s","e","t","p","hasOwnProperty","getOwnPropertySymbols","propertyIsEnumerable","omitObject","_a","modeChecker","mode","isOnSubmit","isOnBlur","isOnChange","useRef","React","useState","useCallback","useEffect","createContext","useForm","reValidateMode","submitFocusError","abortEarly","validateCriteriaMode","errorsRef","touchedFieldsRef","Set","watchFieldsRef","dirtyFieldsRef","fieldsWithValidationRef","validFieldsRef","isValidRef","defaultRenderValuesRef","defaultValuesRef","isUnMount","isWatchAllRef","isSubmittedRef","isDirtyRef","submitCountRef","isSubmittingRef","render","isWindowUndefined","isWeb","isProxyEnabled","readFormState","dirty","isSubmitted","submitCount","touched","isSubmitting","isReValidateOnBlur","isReValidateOnSubmit","validationSchemaOptionRef","combineErrorsRef","reRender","validateFieldCurry","validateFieldsSchemaCurry","renderBaseOnError","shouldRender","skipReRender","shouldReRender","delete","setFieldValue","rawValue","radioRef","selectRef","includes","checkboxRef","setDirty","isDirty","isDirtyChanged","size","setInternalValue","executeValidation","executeSchemaValidation","payload","isMultipleFields","names","previousFormIsValid","triggerValidation","all","every","setValue","shouldValidate","target","currentError","isBlurEvent","shouldSkipValidation","shouldUpdateDirty","shouldUpdateState","validForm","validateSchemaIsValid","then","resetFieldRef","removeEventListenerAndRef","clearError","setInternalError","preventRender","setError","watch","fieldNames","unregister","registerFieldsRef","validateOptions","console","warn","fieldAttributes","currentField","find","fieldToAttachListener","register","refOrValidateRule","validationOptions","handleSubmit","callback","preventDefault","persist","fieldErrors","resolvedPrevious","fieldError","focus","resetRefs","reset","closest","getValues","outputValues","nest","formState","Proxy","prop"],"mappings":"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","file":"static/js/0.3d3faf2d.chunk.js","sourcesContent":["import arrayWithHoles from \"./arrayWithHoles\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit\";\nimport nonIterableRest from \"./nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}","import * as React from 'react';\nimport { createContext, useContext, createElement } from 'react';\n\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n};\r\nconst RADIO_INPUT = 'radio';\r\nconst UNDEFINED = 'undefined';\r\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nfunction attachEventListeners({ field, handleChange, isRadioOrCheckbox, }) {\r\n    const { ref } = field;\r\n    if (!ref.addEventListener) {\r\n        return;\r\n    }\r\n    ref.addEventListener(isRadioOrCheckbox ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n    ref.addEventListener(EVENTS.BLUR, handleChange);\r\n}\n\nvar isUndefined = (val) => val === undefined;\n\nvar isNullOrUndefined = (value) => value === null || isUndefined(value);\n\nvar isArray = (value) => Array.isArray(value);\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\r\nconst reIsPlainProp = /^\\w*$/;\r\nconst rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\nconst reEscapeChar = /\\\\(\\\\)?/g;\r\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\r\nfunction isIndex(value) {\r\n    return reIsUint.test(value) && value > -1;\r\n}\r\nfunction isKey(value) {\r\n    if (isArray(value)) {\r\n        return false;\r\n    }\r\n    return reIsPlainProp.test(value) || !reIsDeepProp.test(value);\r\n}\r\nconst stringToPath = (string) => {\r\n    const result = [];\r\n    string.replace(rePropName, (match, number, quote, string) => {\r\n        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\r\n    });\r\n    return result;\r\n};\r\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : isIndex(tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar combineFieldValues = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!!key.match(/\\[.+\\]/gi) || key.indexOf('.') > 0) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (!ref.removeEventListener) {\r\n        return;\r\n    }\r\n    ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n    ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n    ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n};\n\nvar isRadioInput = (type) => type === RADIO_INPUT;\n\nvar isCheckBoxInput = (type) => type === 'checkbox';\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nfunction findRemovedFieldAndRemoveListener(fields, handleChange, field, forceDelete) {\r\n    if (!field) {\r\n        return;\r\n    }\r\n    const { ref, mutationWatcher } = field;\r\n    if (!ref.type || !fields[ref.name]) {\r\n        return;\r\n    }\r\n    const { name, type } = ref;\r\n    const fieldValue = fields[name];\r\n    if ((isRadioInput(type) || isCheckBoxInput(type)) && fieldValue) {\r\n        const { options } = fieldValue;\r\n        if (isArray(options) && options.length) {\r\n            options.forEach(({ ref }, index) => {\r\n                const option = options[index];\r\n                if ((option && isDetached(ref)) || forceDelete) {\r\n                    const mutationWatcher = option.mutationWatcher;\r\n                    removeAllEventListeners(option, handleChange);\r\n                    if (mutationWatcher) {\r\n                        mutationWatcher.disconnect();\r\n                    }\r\n                    options.splice(index, 1);\r\n                }\r\n            });\r\n            if (options && !options.length) {\r\n                delete fields[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fields[name];\r\n        }\r\n    }\r\n    else if (isDetached(ref) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        if (mutationWatcher) {\r\n            mutationWatcher.disconnect();\r\n        }\r\n        delete fields[name];\r\n    }\r\n}\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, { ref: { checked, value } }) => checked\r\n        ? {\r\n            isValid: true,\r\n            value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isMultipleSelect = (type) => type === 'select-multiple';\n\nvar isEmptyString = (value) => value === '';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter(({ ref: { checked } }) => checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || isEmptyString(value)\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fields, ref) {\r\n    const { type, name, options, value, files } = ref;\r\n    const field = fields[name];\r\n    if (type === 'file') {\r\n        return files;\r\n    }\r\n    if (isRadioInput(type)) {\r\n        return field ? getRadioValue(field.options).value : '';\r\n    }\r\n    if (isMultipleSelect(type)) {\r\n        return getMultipleSelectValue(options);\r\n    }\r\n    if (isCheckBoxInput(type)) {\r\n        return field ? getCheckboxValue(field.options).value : false;\r\n    }\r\n    return value;\r\n}\n\nvar getFieldsValues = (fields) => Object.values(fields).reduce((previous, { ref, ref: { name } }) => (Object.assign(Object.assign({}, previous), { [name]: getFieldValue(fields, ref) })), {});\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar isSameError = (error, type, message) => isObject(error) && error.type === type && error.message === message;\n\nfunction shouldUpdateWithError({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isFieldValid = isEmptyObject(error);\r\n    const isFormValid = isEmptyObject(errors);\r\n    const currentFieldError = error[name];\r\n    const existFieldError = errors[name];\r\n    if ((isFieldValid && validFields.has(name)) ||\r\n        (existFieldError && existFieldError.isManual)) {\r\n        return false;\r\n    }\r\n    if (isFormValid !== isFieldValid ||\r\n        (!isFormValid && !existFieldError) ||\r\n        (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))) {\r\n        return true;\r\n    }\r\n    return (currentFieldError &&\r\n        !isSameError(existFieldError, currentFieldError.type, currentFieldError.message));\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => {\r\n    const isPureObject = isObject(validationData) && !isRegex(validationData);\r\n    return {\r\n        value: isPureObject\r\n            ? validationData.value\r\n            : validationData,\r\n        message: isPureObject\r\n            ? validationData.message\r\n            : '',\r\n    };\r\n};\n\nvar isString = (value) => typeof value === 'string';\n\nvar displayNativeError = (nativeValidation, ref, message) => {\r\n    if (nativeValidation && isString(message)) {\r\n        ref.setCustomValidity(message);\r\n    }\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction getValidateError(result, ref, nativeError, type = 'validate') {\r\n    const isStringValue = isString(result);\r\n    if (isStringValue || (isBoolean(result) && !result)) {\r\n        const message = isStringValue ? result : '';\r\n        const error = {\r\n            type,\r\n            message,\r\n            ref,\r\n        };\r\n        nativeError(message);\r\n        return error;\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (!validateAllFieldCriteria) {\r\n        return {};\r\n    }\r\n    const error = errors[name];\r\n    return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n};\n\nvar validateField = async (fieldsRef, nativeValidation, validateAllFieldCriteria, { ref, ref: { type, value, name, valueAsNumber, valueAsDate }, options, required, maxLength, minLength, min, max, pattern, validate, }) => {\r\n    const fields = fieldsRef.current;\r\n    const error = {};\r\n    const isRadio = isRadioInput(type);\r\n    const isCheckBox = isCheckBoxInput(type);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = isEmptyString(value);\r\n    const nativeError = displayNativeError.bind(null, nativeValidation, ref);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const message = isString(required)\r\n            ? required\r\n            : getValueAndMessage(required).message;\r\n        error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? fields[name].options[0].ref : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n        nativeError(message);\r\n        if (!validateAllFieldCriteria) {\r\n            return error;\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number') {\r\n            const valueNumber = valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue)) {\r\n                exceedMax = valueNumber > maxValue;\r\n            }\r\n            if (!isNullOrUndefined(minValue)) {\r\n                exceedMin = valueNumber < minValue;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = valueAsDate || new Date(value);\r\n            if (isString(maxValue)) {\r\n                exceedMax = valueDate > new Date(maxValue);\r\n            }\r\n            if (isString(minValue)) {\r\n                exceedMin = valueDate < new Date(minValue);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            const message = exceedMax ? maxMessage : minMessage;\r\n            error[name] = Object.assign({ type: exceedMax\r\n                    ? INPUT_VALIDATION_RULES.max\r\n                    : INPUT_VALIDATION_RULES.min, message,\r\n                ref }, (exceedMax\r\n                ? appendErrorsCurry(INPUT_VALIDATION_RULES.max, message)\r\n                : appendErrorsCurry(INPUT_VALIDATION_RULES.min, message)));\r\n            nativeError(message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = maxLength && inputLength > maxLengthValue;\r\n        const exceedMin = minLength && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n            error[name] = Object.assign({ type: exceedMax\r\n                    ? INPUT_VALIDATION_RULES.maxLength\r\n                    : INPUT_VALIDATION_RULES.minLength, message,\r\n                ref }, (exceedMax\r\n                ? appendErrorsCurry(INPUT_VALIDATION_RULES.maxLength, message)\r\n                : appendErrorsCurry(INPUT_VALIDATION_RULES.minLength, message)));\r\n            nativeError(message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\r\n            nativeError(patternMessage);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fields, ref);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef, nativeError);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            const validateFunctions = Object.entries(validate);\r\n            const validationResult = await new Promise((resolve) => {\r\n                validateFunctions.reduce(async (previous, [key, validate], index) => {\r\n                    if ((!isEmptyObject(await previous) && !validateAllFieldCriteria) ||\r\n                        !isFunction(validate)) {\r\n                        return resolve(previous);\r\n                    }\r\n                    let result;\r\n                    const validateResult = await validate(fieldValue);\r\n                    const validateError = getValidateError(validateResult, validateRef, nativeError, key);\r\n                    if (validateError) {\r\n                        result = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                        if (validateAllFieldCriteria) {\r\n                            error[name] = result;\r\n                        }\r\n                    }\r\n                    else {\r\n                        result = previous;\r\n                    }\r\n                    return validateFunctions.length - 1 === index\r\n                        ? resolve(result)\r\n                        : result;\r\n                }, {});\r\n            });\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (nativeValidation) {\r\n        ref.setCustomValidity('');\r\n    }\r\n    return error;\r\n};\n\nconst parseErrorSchema = (error, validateAllFieldCriteria) => isArray(error.inner)\r\n    ? error.inner.reduce((previous, { path, message, type }) => (Object.assign(Object.assign({}, previous), (previous[path] && validateAllFieldCriteria\r\n        ? {\r\n            [path]: appendErrors(path, validateAllFieldCriteria, previous, type, message),\r\n        }\r\n        : {\r\n            [path]: Object.assign({ message,\r\n                type }, (validateAllFieldCriteria\r\n                ? {\r\n                    types: { [type]: message || true },\r\n                }\r\n                : {})),\r\n        }))), {})\r\n    : {\r\n        [error.path]: { message: error.message, type: error.type },\r\n    };\r\nasync function validateWithSchema(validationSchema, validationSchemaOption, validateAllFieldCriteria, data) {\r\n    try {\r\n        return {\r\n            values: await validationSchema.validate(data, validationSchemaOption),\r\n            errors: {},\r\n        };\r\n    }\r\n    catch (e) {\r\n        return {\r\n            values: {},\r\n            errors: parseErrorSchema(e, validateAllFieldCriteria),\r\n        };\r\n    }\r\n}\n\nfunction attachNativeValidation(ref, rules) {\r\n    Object.entries(rules).forEach(([key, ruleValue]) => {\r\n        const { value } = getValueAndMessage(ruleValue);\r\n        if (key === INPUT_VALIDATION_RULES.pattern && isRegex(value)) {\r\n            ref[key] = value.source;\r\n        }\r\n        else {\r\n            ref[key] = key === INPUT_VALIDATION_RULES.pattern || value;\r\n        }\r\n    });\r\n}\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = path\r\n        .split(/[,[\\].]+?/)\r\n        .filter(Boolean)\r\n        .reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj ? defaultValue : result;\r\n};\n\nvar getDefaultValue = (defaultValues, name, defaultValue) => isUndefined(defaultValues[name])\r\n    ? get(defaultValues, name, defaultValue)\r\n    : defaultValues[name];\n\nfunction flatArray(list) {\r\n    return list.reduce((a, b) => a.concat(isArray(b) ? flatArray(b) : b), []);\r\n}\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => isArray(values)\r\n    ? values.map((item, index) => {\r\n        const pathWithIndex = `${path}[${index}]`;\r\n        return isPrimitive(item) ? pathWithIndex : getPath(pathWithIndex, item);\r\n    })\r\n    : Object.entries(values).map(([key, objectValue]) => {\r\n        const pathWithKey = `${path}.${key}`;\r\n        return isPrimitive(objectValue)\r\n            ? pathWithKey\r\n            : getPath(pathWithKey, objectValue);\r\n    });\r\nvar getPath$1 = (parentPath, value) => flatArray(getPath(parentPath, value));\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, combinedDefaultValues) => {\r\n    let value;\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else if (!isUndefined(fieldValues[fieldName])) {\r\n        watchFields.add(fieldName);\r\n        value = fieldValues[fieldName];\r\n    }\r\n    else {\r\n        value = get(combineFieldValues(fieldValues), fieldName);\r\n        if (!isUndefined(value)) {\r\n            getPath$1(fieldName, value).forEach(name => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isObject(combinedDefaultValues)\r\n            ? getDefaultValue(combinedDefaultValues, fieldName)\r\n            : combinedDefaultValues\r\n        : value;\r\n};\n\nvar omitValidFields = (errorFields, validFieldNames) => Object.entries(errorFields).reduce((previous, [name, error]) => validFieldNames.some(validFieldName => validFieldName === name)\r\n    ? previous\r\n    : Object.assign(Object.assign({}, previous), { [name]: error }), {});\n\nfunction onDomRemove(element, onDetachCallback) {\r\n    const observer = new MutationObserver(() => {\r\n        if (isDetached(element)) {\r\n            observer.disconnect();\r\n            onDetachCallback();\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst omitObject = (obj, key) => {\r\n    const _a = key, omitted = obj[_a], rest = __rest(obj, [typeof _a === \"symbol\" ? _a : _a + \"\"]);\r\n    return rest;\r\n};\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n});\n\nconst { useRef, useState, useCallback, useEffect } = React;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, validationSchema, defaultValues = {}, nativeValidation = false, submitFocusError = true, validationSchemaOption = { abortEarly: false }, validateCriteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const validateAllFieldCriteria = validateCriteriaMode === 'all';\r\n    const errorsRef = useRef({});\r\n    const touchedFieldsRef = useRef(new Set());\r\n    const watchFieldsRef = useRef(new Set());\r\n    const dirtyFieldsRef = useRef(new Set());\r\n    const fieldsWithValidationRef = useRef(new Set());\r\n    const validFieldsRef = useRef(new Set());\r\n    const isValidRef = useRef(true);\r\n    const defaultRenderValuesRef = useRef({});\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const isSubmittedRef = useRef(false);\r\n    const isDirtyRef = useRef(false);\r\n    const submitCountRef = useRef(0);\r\n    const isSubmittingRef = useRef(false);\r\n    const handleChange = useRef();\r\n    const [, render] = useState();\r\n    const { isOnBlur, isOnSubmit } = useRef(modeChecker(mode)).current;\r\n    const isWindowUndefined = typeof window === UNDEFINED;\r\n    const isWeb = typeof document !== UNDEFINED &&\r\n        !isWindowUndefined &&\r\n        !isUndefined(window.HTMLElement);\r\n    const isProxyEnabled = !isWindowUndefined && 'Proxy' in window;\r\n    const readFormState = useRef({\r\n        dirty: !isProxyEnabled,\r\n        isSubmitted: isOnSubmit,\r\n        submitCount: !isProxyEnabled,\r\n        touched: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const { isOnBlur: isReValidateOnBlur, isOnSubmit: isReValidateOnSubmit, } = useRef(modeChecker(reValidateMode)).current;\r\n    const validationSchemaOptionRef = useRef(validationSchemaOption);\r\n    defaultValuesRef.current = defaultValuesRef.current\r\n        ? defaultValuesRef.current\r\n        : defaultValues;\r\n    const combineErrorsRef = (data) => (Object.assign(Object.assign({}, errorsRef.current), data));\r\n    const reRender = useCallback(() => {\r\n        if (!isUnMount.current) {\r\n            render({});\r\n        }\r\n    }, []);\r\n    const validateFieldCurry = useCallback(validateField.bind(null, fieldsRef, nativeValidation, validateAllFieldCriteria), []);\r\n    const validateFieldsSchemaCurry = useCallback(validateWithSchema.bind(null, validationSchema, validationSchemaOptionRef.current, validateAllFieldCriteria), [validationSchema]);\r\n    const renderBaseOnError = useCallback((name, error, shouldRender, skipReRender) => {\r\n        let shouldReRender = shouldRender ||\r\n            shouldUpdateWithError({\r\n                errors: errorsRef.current,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        if (isEmptyObject(error)) {\r\n            if (fieldsWithValidationRef.current.has(name) || validationSchema) {\r\n                validFieldsRef.current.add(name);\r\n                shouldReRender = shouldReRender || errorsRef.current[name];\r\n            }\r\n            errorsRef.current = omitObject(errorsRef.current, name);\r\n        }\r\n        else {\r\n            validFieldsRef.current.delete(name);\r\n            shouldReRender = shouldReRender || !errorsRef.current[name];\r\n        }\r\n        errorsRef.current = combineErrorsRef(error);\r\n        if (shouldReRender && !skipReRender) {\r\n            reRender();\r\n            return true;\r\n        }\r\n    }, [reRender, validationSchema]);\r\n    const setFieldValue = useCallback((name, rawValue) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!field) {\r\n            return false;\r\n        }\r\n        const ref = field.ref;\r\n        const { type } = ref;\r\n        const options = field.options;\r\n        const value = isWeb &&\r\n            ref instanceof window.HTMLElement &&\r\n            isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(type) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isMultipleSelect(type)) {\r\n            [...ref.options].forEach(selectRef => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(type) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = value.includes(checkboxRef.value)))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n        return type;\r\n    }, [isWeb]);\r\n    const setDirty = (name) => {\r\n        if (!fieldsRef.current[name]) {\r\n            return false;\r\n        }\r\n        const isDirty = defaultRenderValuesRef.current[name] !==\r\n            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);\r\n        const isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;\r\n        if (isDirty) {\r\n            dirtyFieldsRef.current.add(name);\r\n        }\r\n        else {\r\n            dirtyFieldsRef.current.delete(name);\r\n        }\r\n        isDirtyRef.current = !!dirtyFieldsRef.current.size;\r\n        return isDirtyChanged && readFormState.current.dirty;\r\n    };\r\n    const setInternalValue = useCallback((name, value) => {\r\n        setFieldValue(name, value);\r\n        if (setDirty(name) ||\r\n            (!touchedFieldsRef.current.has(name) && readFormState.current.touched)) {\r\n            return !!touchedFieldsRef.current.add(name);\r\n        }\r\n    }, [setFieldValue]);\r\n    const executeValidation = useCallback(async ({ name, value, }, shouldRender, skipReRender) => {\r\n        const field = fieldsRef.current[name];\r\n        if (!field) {\r\n            return false;\r\n        }\r\n        if (!isUndefined(value)) {\r\n            setInternalValue(name, value);\r\n        }\r\n        if (shouldRender) {\r\n            reRender();\r\n        }\r\n        const error = await validateField(fieldsRef, nativeValidation, validateAllFieldCriteria, field);\r\n        renderBaseOnError(name, error, false, skipReRender);\r\n        return isEmptyObject(error);\r\n    }, [\r\n        nativeValidation,\r\n        reRender,\r\n        renderBaseOnError,\r\n        setInternalValue,\r\n        validateAllFieldCriteria,\r\n    ]);\r\n    const executeSchemaValidation = useCallback(async (payload, shouldRender) => {\r\n        const { errors } = await validateWithSchema(validationSchema, validationSchemaOptionRef.current, validateAllFieldCriteria, combineFieldValues(getFieldsValues(fieldsRef.current)));\r\n        const isMultipleFields = isArray(payload);\r\n        const names = isArray(payload)\r\n            ? payload.map(({ name }) => name)\r\n            : [payload.name];\r\n        const validFieldNames = names.filter(name => !errors[name]);\r\n        const previousFormIsValid = isValidRef.current;\r\n        isValidRef.current = isEmptyObject(errors);\r\n        if (isMultipleFields) {\r\n            errorsRef.current = omitValidFields(combineErrorsRef(Object.entries(errors)\r\n                .filter(([key]) => names.includes(key))\r\n                .reduce((previous, [name, error]) => (Object.assign(Object.assign({}, previous), { [name]: error })), {})), validFieldNames);\r\n            reRender();\r\n        }\r\n        else {\r\n            const fieldName = names[0];\r\n            renderBaseOnError(fieldName, errors[fieldName]\r\n                ? { [fieldName]: errors[fieldName] }\r\n                : {}, shouldRender || previousFormIsValid !== isValidRef.current);\r\n        }\r\n        return isEmptyObject(errorsRef.current);\r\n    }, [reRender, renderBaseOnError, validateAllFieldCriteria, validationSchema]);\r\n    const triggerValidation = useCallback(async (payload, shouldRender) => {\r\n        const fields = payload || Object.keys(fieldsRef.current).map(name => ({ name }));\r\n        if (validationSchema) {\r\n            return executeSchemaValidation(fields, shouldRender);\r\n        }\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, false, true)));\r\n            reRender();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields, shouldRender);\r\n    }, [executeSchemaValidation, executeValidation, reRender, validationSchema]);\r\n    const setValue = useCallback((name, value, shouldValidate) => {\r\n        const shouldRender = setInternalValue(name, value) ||\r\n            isWatchAllRef.current ||\r\n            watchFieldsRef.current.has(name);\r\n        if (shouldValidate) {\r\n            return triggerValidation({ name }, shouldRender);\r\n        }\r\n        if (shouldRender) {\r\n            reRender();\r\n        }\r\n        return;\r\n    }, [reRender, setInternalValue, triggerValidation]);\r\n    handleChange.current = handleChange.current\r\n        ? handleChange.current\r\n        : async ({ type, target }) => {\r\n            const name = target ? target.name : '';\r\n            const fields = fieldsRef.current;\r\n            const errors = errorsRef.current;\r\n            const field = fields[name];\r\n            const currentError = errors[name];\r\n            let error;\r\n            if (!field) {\r\n                return;\r\n            }\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const shouldSkipValidation = (isOnSubmit && isReValidateOnSubmit) ||\r\n                (isOnSubmit && !isSubmittedRef.current) ||\r\n                (isOnBlur && !isBlurEvent && !currentError) ||\r\n                (isReValidateOnBlur && !isBlurEvent && currentError) ||\r\n                (isReValidateOnSubmit && currentError);\r\n            const shouldUpdateDirty = setDirty(name);\r\n            let shouldUpdateState = isWatchAllRef.current ||\r\n                watchFieldsRef.current.has(name) ||\r\n                shouldUpdateDirty;\r\n            if (isBlurEvent &&\r\n                !touchedFieldsRef.current.has(name) &&\r\n                readFormState.current.touched) {\r\n                touchedFieldsRef.current.add(name);\r\n                shouldUpdateState = true;\r\n            }\r\n            if (shouldSkipValidation) {\r\n                return shouldUpdateState && reRender();\r\n            }\r\n            if (validationSchema) {\r\n                const { errors } = await validateWithSchema(validationSchema, validationSchemaOptionRef.current, validateAllFieldCriteria, combineFieldValues(getFieldsValues(fields)));\r\n                const validForm = isEmptyObject(errors);\r\n                error = (errors[name] ? { [name]: errors[name] } : {});\r\n                if (isValidRef.current !== validForm) {\r\n                    shouldUpdateState = true;\r\n                }\r\n                isValidRef.current = validForm;\r\n            }\r\n            else {\r\n                error = await validateField(fieldsRef, nativeValidation, validateAllFieldCriteria, field);\r\n            }\r\n            if (!renderBaseOnError(name, error) && shouldUpdateState) {\r\n                reRender();\r\n            }\r\n        };\r\n    const validateSchemaIsValid = useCallback(() => {\r\n        const fieldValues = isEmptyObject(defaultValuesRef.current)\r\n            ? getFieldsValues(fieldsRef.current)\r\n            : defaultValuesRef.current;\r\n        validateFieldsSchemaCurry(combineFieldValues(fieldValues)).then(({ errors }) => {\r\n            const previousFormIsValid = isValidRef.current;\r\n            isValidRef.current = isEmptyObject(errors);\r\n            if (previousFormIsValid && previousFormIsValid !== isValidRef.current) {\r\n                reRender();\r\n            }\r\n        });\r\n    }, [reRender, validateFieldsSchemaCurry]);\r\n    const resetFieldRef = useCallback((name) => {\r\n        errorsRef.current = omitObject(errorsRef.current, name);\r\n        fieldsRef.current = omitObject(fieldsRef.current, name);\r\n        defaultRenderValuesRef.current = omitObject(defaultRenderValuesRef.current, name);\r\n        [\r\n            touchedFieldsRef,\r\n            dirtyFieldsRef,\r\n            fieldsWithValidationRef,\r\n            validFieldsRef,\r\n            watchFieldsRef,\r\n        ].forEach(data => data.current.delete(name));\r\n        if (readFormState.current.isValid || readFormState.current.touched) {\r\n            reRender();\r\n        }\r\n        if (validationSchema) {\r\n            validateSchemaIsValid();\r\n        }\r\n    }, [reRender]);\r\n    const removeEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (!field) {\r\n            return;\r\n        }\r\n        if (!isUndefined(handleChange.current)) {\r\n            findRemovedFieldAndRemoveListener(fieldsRef.current, handleChange.current, field, forceDelete);\r\n        }\r\n        resetFieldRef(field.ref.name);\r\n    }, [resetFieldRef]);\r\n    function clearError(name) {\r\n        if (isUndefined(name)) {\r\n            errorsRef.current = {};\r\n        }\r\n        else {\r\n            (isArray(name) ? name : [name]).forEach(fieldName => (errorsRef.current = omitObject(errorsRef.current, fieldName)));\r\n        }\r\n        reRender();\r\n    }\r\n    const setInternalError = ({ name, type, types, message, preventRender, }) => {\r\n        const errors = errorsRef.current;\r\n        const field = fieldsRef.current[name];\r\n        if (!isSameError(errors[name], type, message)) {\r\n            errors[name] = {\r\n                type,\r\n                types,\r\n                message,\r\n                ref: field ? field.ref : {},\r\n                isManual: true,\r\n            };\r\n            if (!preventRender) {\r\n                reRender();\r\n            }\r\n        }\r\n    };\r\n    function setError(name, type = '', message) {\r\n        if (isString(name)) {\r\n            setInternalError(Object.assign({ name }, (isObject(type)\r\n                ? {\r\n                    types: type,\r\n                    type: '',\r\n                }\r\n                : {\r\n                    type,\r\n                    message,\r\n                })));\r\n        }\r\n        else if (isArray(name)) {\r\n            name.forEach(error => setInternalError(Object.assign(Object.assign({}, error), { preventRender: true })));\r\n            reRender();\r\n        }\r\n    }\r\n    function watch(fieldNames, defaultValue) {\r\n        const combinedDefaultValues = isUndefined(defaultValue)\r\n            ? isUndefined(defaultValues)\r\n                ? {}\r\n                : defaultValues\r\n            : defaultValue;\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const watchFields = watchFieldsRef.current;\r\n        if (isProxyEnabled) {\r\n            readFormState.current.dirty = true;\r\n        }\r\n        if (isString(fieldNames)) {\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, combinedDefaultValues);\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => {\r\n                let value;\r\n                if (isEmptyObject(fieldsRef.current) &&\r\n                    isObject(combinedDefaultValues)) {\r\n                    value = getDefaultValue(combinedDefaultValues, name);\r\n                }\r\n                else {\r\n                    value = assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues);\r\n                }\r\n                return Object.assign(Object.assign({}, previous), { [name]: value });\r\n            }, {});\r\n        }\r\n        isWatchAllRef.current = true;\r\n        return ((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            defaultValue ||\r\n            defaultValues);\r\n    }\r\n    function unregister(names) {\r\n        if (!isEmptyObject(fieldsRef.current)) {\r\n            (isArray(names) ? names : [names]).forEach(fieldName => removeEventListenerAndRef(fieldsRef.current[fieldName], true));\r\n        }\r\n    }\r\n    function registerFieldsRef(ref, validateOptions = {}) {\r\n        if (!ref.name) {\r\n            return console.warn('Missing name @', ref);\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldAttributes = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioInput(type) || isCheckBoxInput(type);\r\n        let currentField = fields[name];\r\n        if (isRadioOrCheckbox\r\n            ? currentField &&\r\n                isArray(currentField.options) &&\r\n                currentField.options.find(({ ref }) => value === ref.value)\r\n            : currentField) {\r\n            fields[name] = Object.assign(Object.assign({}, currentField), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            const mutationWatcher = onDomRemove(ref, () => removeEventListenerAndRef(fieldAttributes));\r\n            if (isRadioOrCheckbox) {\r\n                currentField = Object.assign({ options: [\r\n                        ...((currentField && currentField.options) || []),\r\n                        {\r\n                            ref,\r\n                            mutationWatcher,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions);\r\n            }\r\n            else {\r\n                currentField = Object.assign(Object.assign({}, fieldAttributes), { mutationWatcher });\r\n            }\r\n        }\r\n        else {\r\n            currentField = fieldAttributes;\r\n        }\r\n        fields[name] = currentField;\r\n        if (!isEmptyObject(defaultValuesRef.current)) {\r\n            const defaultValue = getDefaultValue(defaultValuesRef.current, name);\r\n            if (!isUndefined(defaultValue)) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if (validationSchema) {\r\n            validateSchemaIsValid();\r\n        }\r\n        else if (!isEmptyObject(validateOptions)) {\r\n            fieldsWithValidationRef.current.add(name);\r\n            if (!isOnSubmit && readFormState.current.isValid) {\r\n                validateFieldCurry(currentField).then(error => {\r\n                    const previousFormIsValid = isValidRef.current;\r\n                    if (isEmptyObject(error)) {\r\n                        validFieldsRef.current.add(name);\r\n                    }\r\n                    else {\r\n                        isValidRef.current = false;\r\n                    }\r\n                    if (previousFormIsValid !== isValidRef.current) {\r\n                        reRender();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultRenderValuesRef.current[name]) {\r\n            defaultRenderValuesRef.current[name] = getFieldValue(fields, currentField.ref);\r\n        }\r\n        if (!type) {\r\n            return;\r\n        }\r\n        const fieldToAttachListener = isRadioOrCheckbox && currentField.options\r\n            ? currentField.options[currentField.options.length - 1]\r\n            : currentField;\r\n        if (nativeValidation && validateOptions) {\r\n            attachNativeValidation(ref, validateOptions);\r\n        }\r\n        else {\r\n            attachEventListeners({\r\n                field: fieldToAttachListener,\r\n                isRadioOrCheckbox,\r\n                handleChange: handleChange.current,\r\n            });\r\n        }\r\n    }\r\n    function register(refOrValidateRule, validationOptions) {\r\n        if (isWindowUndefined || !refOrValidateRule) {\r\n            return;\r\n        }\r\n        if (validationOptions && isString(validationOptions.name)) {\r\n            registerFieldsRef({ name: validationOptions.name }, validationOptions);\r\n            return;\r\n        }\r\n        if (isObject(refOrValidateRule) && 'name' in refOrValidateRule) {\r\n            registerFieldsRef(refOrValidateRule, validationOptions);\r\n            return;\r\n        }\r\n        return (ref) => ref && registerFieldsRef(ref, refOrValidateRule);\r\n    }\r\n    const handleSubmit = useCallback((callback) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors;\r\n        let fieldValues;\r\n        const fields = fieldsRef.current;\r\n        if (readFormState.current.isSubmitting) {\r\n            isSubmittingRef.current = true;\r\n            reRender();\r\n        }\r\n        try {\r\n            if (validationSchema) {\r\n                fieldValues = getFieldsValues(fields);\r\n                const { errors, values } = await validateFieldsSchemaCurry(combineFieldValues(fieldValues));\r\n                errorsRef.current = errors;\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                const { errors, values, } = await Object.values(fields).reduce(async (previous, field) => {\r\n                    if (!field) {\r\n                        return previous;\r\n                    }\r\n                    const resolvedPrevious = await previous;\r\n                    const { ref, ref: { name }, } = field;\r\n                    if (!fields[name]) {\r\n                        return Promise.resolve(resolvedPrevious);\r\n                    }\r\n                    const fieldError = await validateFieldCurry(field);\r\n                    if (fieldError[name]) {\r\n                        resolvedPrevious.errors = Object.assign(Object.assign({}, resolvedPrevious.errors), fieldError);\r\n                        validFieldsRef.current.delete(name);\r\n                        return Promise.resolve(resolvedPrevious);\r\n                    }\r\n                    if (fieldsWithValidationRef.current.has(name)) {\r\n                        validFieldsRef.current.add(name);\r\n                    }\r\n                    resolvedPrevious.values[name] = getFieldValue(fields, ref);\r\n                    return Promise.resolve(resolvedPrevious);\r\n                }, Promise.resolve({\r\n                    errors: {},\r\n                    values: {},\r\n                }));\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            if (isEmptyObject(fieldErrors)) {\r\n                errorsRef.current = {};\r\n                await callback(combineFieldValues(fieldValues), e);\r\n            }\r\n            else {\r\n                if (submitFocusError) {\r\n                    Object.keys(fieldErrors).reduce((previous, current) => {\r\n                        const field = fields[current];\r\n                        if (field && previous) {\r\n                            if (field.ref.focus) {\r\n                                field.ref.focus();\r\n                                return false;\r\n                            }\r\n                            else if (field.options) {\r\n                                field.options[0].ref.focus();\r\n                                return false;\r\n                            }\r\n                        }\r\n                        return previous;\r\n                    }, true);\r\n                }\r\n                errorsRef.current = fieldErrors;\r\n            }\r\n        }\r\n        finally {\r\n            isSubmittedRef.current = true;\r\n            isSubmittingRef.current = false;\r\n            submitCountRef.current = submitCountRef.current + 1;\r\n            reRender();\r\n        }\r\n    }, [\r\n        reRender,\r\n        submitFocusError,\r\n        validateFieldCurry,\r\n        validateFieldsSchemaCurry,\r\n        validationSchema,\r\n    ]);\r\n    const resetRefs = () => {\r\n        errorsRef.current = {};\r\n        fieldsRef.current = {};\r\n        validFieldsRef.current = new Set();\r\n        fieldsWithValidationRef.current = new Set();\r\n        defaultRenderValuesRef.current = {};\r\n        touchedFieldsRef.current = new Set();\r\n        watchFieldsRef.current = new Set();\r\n        dirtyFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        isSubmittedRef.current = false;\r\n        isDirtyRef.current = false;\r\n        isValidRef.current = true;\r\n        submitCountRef.current = 0;\r\n    };\r\n    const reset = useCallback((values) => {\r\n        const fieldsKeyValue = Object.entries(fieldsRef.current);\r\n        for (const [, value] of fieldsKeyValue) {\r\n            if (value && value.ref && value.ref.closest) {\r\n                try {\r\n                    value.ref.closest('form').reset();\r\n                    break;\r\n                }\r\n                catch (_a) { }\r\n            }\r\n        }\r\n        resetRefs();\r\n        if (values) {\r\n            defaultValuesRef.current = values;\r\n        }\r\n        reRender();\r\n    }, [reRender]);\r\n    const getValues = useCallback((payload) => {\r\n        const fieldValues = getFieldsValues(fieldsRef.current);\r\n        const outputValues = isEmptyObject(fieldValues)\r\n            ? defaultValues\r\n            : fieldValues;\r\n        return payload && payload.nest\r\n            ? combineFieldValues(outputValues)\r\n            : outputValues;\r\n    }, [defaultValues]);\r\n    useEffect(() => () => {\r\n        isUnMount.current = true;\r\n        fieldsRef.current &&\r\n            Object.values(fieldsRef.current).forEach((field) => removeEventListenerAndRef(field, true));\r\n    }, [removeEventListenerAndRef]);\r\n    if (!validationSchema) {\r\n        isValidRef.current =\r\n            validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&\r\n                isEmptyObject(errorsRef.current);\r\n    }\r\n    const formState = {\r\n        dirty: isDirtyRef.current,\r\n        isSubmitted: isSubmittedRef.current,\r\n        submitCount: submitCountRef.current,\r\n        touched: [...touchedFieldsRef.current],\r\n        isSubmitting: isSubmittingRef.current,\r\n        isValid: isOnSubmit\r\n            ? isSubmittedRef.current && isEmptyObject(errorsRef.current)\r\n            : isEmptyObject(fieldsRef.current) || isValidRef.current,\r\n    };\r\n    return {\r\n        register: useCallback(register, [\r\n            defaultRenderValuesRef.current,\r\n            defaultValuesRef.current,\r\n        ]),\r\n        unregister: useCallback(unregister, [removeEventListenerAndRef]),\r\n        clearError: useCallback(clearError, []),\r\n        setError: useCallback(setError, []),\r\n        handleSubmit,\r\n        watch,\r\n        reset,\r\n        setValue,\r\n        triggerValidation,\r\n        getValues,\r\n        errors: errorsRef.current,\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (prop in obj) {\r\n                        readFormState.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return {};\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n}\n\nconst FormGlobalContext = createContext(null);\r\nfunction useFormContext() {\r\n    return useContext(FormGlobalContext);\r\n}\r\nfunction FormContext(props) {\r\n    const { children, formState, errors } = props, restMethods = __rest(props, [\"children\", \"formState\", \"errors\"]);\r\n    return (createElement(FormGlobalContext.Provider, { value: Object.assign(Object.assign({}, restMethods), { formState, errors }) }, children));\r\n}\n\nexport default useForm;\nexport { FormContext, useFormContext };\n"],"sourceRoot":""}